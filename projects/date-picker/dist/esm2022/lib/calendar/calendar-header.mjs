/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ChangeDetectionStrategy, Component, forwardRef, Inject, Optional, ViewEncapsulation, } from '@angular/core';
import { DATE_FORMATS } from '../adapter';
import { getActiveOffset, isSameMultiYearView, yearsPerPage } from './multi-year-view';
import { Calendar } from './calendar';
import * as i0 from "@angular/core";
import * as i1 from "../adapter";
import * as i2 from "./calendar";
let calendarHeaderId = 1;
/** Default header for MatCalendar */
export class CalendarHeader {
    calendar;
    _dateAdapter;
    _dateFormats;
    constructor(calendar, _dateAdapter, _dateFormats, changeDetectorRef) {
        this.calendar = calendar;
        this._dateAdapter = _dateAdapter;
        this._dateFormats = _dateFormats;
        this.calendar.stateChanges.subscribe(() => changeDetectorRef.markForCheck());
    }
    /** The display text for the current calendar view. */
    get periodButtonText() {
        if (this.calendar.currentView == 'month') {
            return this._dateAdapter
                .format(this.calendar.activeDate, this._dateFormats.display.monthYearLabel)
                .toLocaleUpperCase();
        }
        if (this.calendar.currentView == 'year') {
            return this._dateAdapter.getYearName(this.calendar.activeDate);
        }
        const [start, end] = this._formatMinAndMaxYearLabels();
        return `${start} \u2013 ${end}`;
    }
    /** The aria description for the current calendar view. */
    get periodButtonDescription() {
        if (this.calendar.currentView == 'month') {
            return this._dateAdapter
                .format(this.calendar.activeDate, this._dateFormats.display.monthYearLabel)
                .toLocaleUpperCase();
        }
        if (this.calendar.currentView == 'year') {
            return this._dateAdapter.getYearName(this.calendar.activeDate);
        }
        // Format a label for the window of years displayed in the multi-year calendar view. Use
        // `formatYearRangeLabel` because it is TTS friendly.
        const [start, end] = this._formatMinAndMaxYearLabels();
        return `${start} \u2013 ${end}`;
    }
    /** The `aria-label` for changing the calendar view. */
    get periodButtonLabel() {
        // TODO: translate
        return this.calendar.currentView == 'month' ? 'Choose month and year' : 'Choose date';
    }
    /** The label for the previous button. */
    get prevButtonLabel() {
        // TODO: translate
        return {
            month: 'Previous month',
            year: 'Previous year',
            'multi-year': 'Previous 24 years',
        }[this.calendar.currentView];
    }
    /** The label for the next button. */
    get nextButtonLabel() {
        // TODO: translate
        return {
            month: 'Next month',
            year: 'Next year',
            'multi-year': 'Next 24 years',
        }[this.calendar.currentView];
    }
    /** Handles user clicks on the period label. */
    currentPeriodClicked() {
        this.calendar.currentView = this.calendar.currentView == 'month' ? 'multi-year' : 'month';
    }
    /** Handles user clicks on the previous button. */
    previousClicked() {
        this.calendar.activeDate =
            this.calendar.currentView == 'month'
                ? this._dateAdapter.addCalendarMonths(this.calendar.activeDate, -1)
                : this._dateAdapter.addCalendarYears(this.calendar.activeDate, this.calendar.currentView == 'year' ? -1 : -yearsPerPage);
    }
    /** Handles user clicks on the next button. */
    nextClicked() {
        this.calendar.activeDate =
            this.calendar.currentView == 'month'
                ? this._dateAdapter.addCalendarMonths(this.calendar.activeDate, 1)
                : this._dateAdapter.addCalendarYears(this.calendar.activeDate, this.calendar.currentView == 'year' ? 1 : yearsPerPage);
    }
    /** Whether the previous period button is enabled. */
    previousEnabled() {
        if (!this.calendar.minDate) {
            return true;
        }
        return (!this.calendar.minDate || !this._isSameView(this.calendar.activeDate, this.calendar.minDate));
    }
    /** Whether the next period button is enabled. */
    nextEnabled() {
        return (!this.calendar.maxDate || !this._isSameView(this.calendar.activeDate, this.calendar.maxDate));
    }
    /** Whether the two dates represent the same view in the current view mode (month or year). */
    _isSameView(date1, date2) {
        if (this.calendar.currentView == 'month') {
            return (this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2) &&
                this._dateAdapter.getMonth(date1) == this._dateAdapter.getMonth(date2));
        }
        if (this.calendar.currentView == 'year') {
            return this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2);
        }
        // Otherwise we are in 'multi-year' view.
        return isSameMultiYearView(this._dateAdapter, date1, date2, this.calendar.minDate, this.calendar.maxDate);
    }
    /**
     * Format two individual labels for the minimum year and maximum year available in the multi-year
     * calendar view. Returns an array of two strings where the first string is the formatted label
     * for the minimum year, and the second string is the formatted label for the maximum year.
     */
    _formatMinAndMaxYearLabels() {
        // The offset from the active year to the "slot" for the starting year is the
        // *actual* first rendered year in the multi-year view, and the last year is
        // just yearsPerPage - 1 away.
        const activeYear = this._dateAdapter.getYear(this.calendar.activeDate);
        const minYearOfPage = activeYear -
            getActiveOffset(this._dateAdapter, this.calendar.activeDate, this.calendar.minDate, this.calendar.maxDate);
        const maxYearOfPage = minYearOfPage + yearsPerPage - 1;
        const minYearLabel = this._dateAdapter.getYearName(this._dateAdapter.createDate(minYearOfPage, 0, 1));
        const maxYearLabel = this._dateAdapter.getYearName(this._dateAdapter.createDate(maxYearOfPage, 0, 1));
        return [minYearLabel, maxYearLabel];
    }
    _id = `calendar-header-${calendarHeaderId++}`;
    _periodButtonLabelId = `${this._id}-period-label`;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CalendarHeader, deps: [{ token: forwardRef(() => Calendar) }, { token: i1.DateAdapter, optional: true }, { token: DATE_FORMATS, optional: true }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: CalendarHeader, isStandalone: true, selector: "calendar-header", exportAs: ["calendarHeader"], ngImport: i0, template: "<div class=\"px-3 pt-2.5 pb-0 flex items-center justify-between\">\n  <!-- [Firefox Issue: https://bugzilla.mozilla.org/show_bug.cgi?id=1880533]\n    Relocated label next to related button and made visually hidden via cdk-visually-hidden\n    to enable label to appear in a11y tree for SR when using Firefox -->\n  <label\n    class=\"hidden cdk-visually-hidden\"\n    for=\"\"\n    [id]=\"_periodButtonLabelId\"\n  >\n    {{ periodButtonDescription }}\n  </label>\n\n  <button\n    class=\"btn btn-ghost\"\n    aria-live=\"polite\"\n    [attr.aria-label]=\"periodButtonLabel\"\n    [attr.aria-describedby]=\"_periodButtonLabelId\"\n    (click)=\"currentPeriodClicked()\"\n  >\n    <span aria-hidden=\"true\">{{ periodButtonText }}</span>\n\n    <svg\n      class=\"w-3 h-3\"\n      fill=\"none\"\n      viewBox=\"0 0 24 24\"\n      stroke-width=\"3\"\n      stroke=\"currentColor\"\n    >\n      <path\n        stroke-linecap=\"round\"\n        stroke-linejoin=\"round\"\n        d=\"m19.5 8.25-7.5 7.5-7.5-7.5\"\n      />\n    </svg>\n  </button>\n\n  <div class=\"flex-auto\"></div>\n\n  <ng-content />\n\n  <button\n    type=\"button\"\n    class=\"btn btn-ghost btn-circle btn-sm\"\n    [disabled]=\"!previousEnabled()\"\n    [attr.aria-label]=\"prevButtonLabel\"\n    (click)=\"previousClicked()\"\n  >\n    <svg\n      class=\"w-6 h-6\"\n      fill=\"none\"\n      viewBox=\"0 0 24 24\"\n      stroke-width=\"2\"\n      stroke=\"currentColor\"\n    >\n      <path\n        stroke-linecap=\"round\"\n        stroke-linejoin=\"round\"\n        d=\"M15.75 19.5 8.25 12l7.5-7.5\"\n      />\n    </svg>\n  </button>\n\n  <button\n    type=\"button\"\n    class=\"btn btn-ghost btn-circle btn-sm\"\n    [disabled]=\"!nextEnabled()\"\n    [attr.aria-label]=\"nextButtonLabel\"\n    (click)=\"nextClicked()\"\n  >\n    <svg\n      class=\"w-6 h-6\"\n      fill=\"none\"\n      viewBox=\"0 0 24 24\"\n      stroke-width=\"2\"\n      stroke=\"currentColor\"\n    >\n      <path\n        stroke-linecap=\"round\"\n        stroke-linejoin=\"round\"\n        d=\"m8.25 4.5 7.5 7.5-7.5 7.5\"\n      />\n    </svg>\n  </button>\n</div>\n", changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CalendarHeader, decorators: [{
            type: Component,
            args: [{ standalone: true, selector: 'calendar-header', encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, exportAs: 'calendarHeader', template: "<div class=\"px-3 pt-2.5 pb-0 flex items-center justify-between\">\n  <!-- [Firefox Issue: https://bugzilla.mozilla.org/show_bug.cgi?id=1880533]\n    Relocated label next to related button and made visually hidden via cdk-visually-hidden\n    to enable label to appear in a11y tree for SR when using Firefox -->\n  <label\n    class=\"hidden cdk-visually-hidden\"\n    for=\"\"\n    [id]=\"_periodButtonLabelId\"\n  >\n    {{ periodButtonDescription }}\n  </label>\n\n  <button\n    class=\"btn btn-ghost\"\n    aria-live=\"polite\"\n    [attr.aria-label]=\"periodButtonLabel\"\n    [attr.aria-describedby]=\"_periodButtonLabelId\"\n    (click)=\"currentPeriodClicked()\"\n  >\n    <span aria-hidden=\"true\">{{ periodButtonText }}</span>\n\n    <svg\n      class=\"w-3 h-3\"\n      fill=\"none\"\n      viewBox=\"0 0 24 24\"\n      stroke-width=\"3\"\n      stroke=\"currentColor\"\n    >\n      <path\n        stroke-linecap=\"round\"\n        stroke-linejoin=\"round\"\n        d=\"m19.5 8.25-7.5 7.5-7.5-7.5\"\n      />\n    </svg>\n  </button>\n\n  <div class=\"flex-auto\"></div>\n\n  <ng-content />\n\n  <button\n    type=\"button\"\n    class=\"btn btn-ghost btn-circle btn-sm\"\n    [disabled]=\"!previousEnabled()\"\n    [attr.aria-label]=\"prevButtonLabel\"\n    (click)=\"previousClicked()\"\n  >\n    <svg\n      class=\"w-6 h-6\"\n      fill=\"none\"\n      viewBox=\"0 0 24 24\"\n      stroke-width=\"2\"\n      stroke=\"currentColor\"\n    >\n      <path\n        stroke-linecap=\"round\"\n        stroke-linejoin=\"round\"\n        d=\"M15.75 19.5 8.25 12l7.5-7.5\"\n      />\n    </svg>\n  </button>\n\n  <button\n    type=\"button\"\n    class=\"btn btn-ghost btn-circle btn-sm\"\n    [disabled]=\"!nextEnabled()\"\n    [attr.aria-label]=\"nextButtonLabel\"\n    (click)=\"nextClicked()\"\n  >\n    <svg\n      class=\"w-6 h-6\"\n      fill=\"none\"\n      viewBox=\"0 0 24 24\"\n      stroke-width=\"2\"\n      stroke=\"currentColor\"\n    >\n      <path\n        stroke-linecap=\"round\"\n        stroke-linejoin=\"round\"\n        d=\"m8.25 4.5 7.5 7.5-7.5 7.5\"\n      />\n    </svg>\n  </button>\n</div>\n" }]
        }], ctorParameters: () => [{ type: i2.Calendar, decorators: [{
                    type: Inject,
                    args: [forwardRef(() => Calendar)]
                }] }, { type: i1.DateAdapter, decorators: [{
                    type: Optional
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [DATE_FORMATS]
                }] }, { type: i0.ChangeDetectorRef }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXItaGVhZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2xpYi9jYWxlbmRhci9jYWxlbmRhci1oZWFkZXIudHMiLCIuLi8uLi8uLi8uLi9zcmMvbGliL2NhbGVuZGFyL2NhbGVuZGFyLWhlYWRlci5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUVILE9BQU8sRUFDTCx1QkFBdUIsRUFFdkIsU0FBUyxFQUNULFVBQVUsRUFDVixNQUFNLEVBQ04sUUFBUSxFQUNSLGlCQUFpQixHQUNsQixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQWUsWUFBWSxFQUFlLE1BQU0sWUFBWSxDQUFDO0FBQ3BFLE9BQU8sRUFBRSxlQUFlLEVBQUUsbUJBQW1CLEVBQUUsWUFBWSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDdkYsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLFlBQVksQ0FBQzs7OztBQUV0QyxJQUFJLGdCQUFnQixHQUFHLENBQUMsQ0FBQztBQUV6QixxQ0FBcUM7QUFTckMsTUFBTSxPQUFPLGNBQWM7SUFFb0I7SUFDdkI7SUFDc0I7SUFINUMsWUFDNkMsUUFBcUIsRUFDNUMsWUFBNEIsRUFDTixZQUF5QixFQUNuRSxpQkFBb0M7UUFITyxhQUFRLEdBQVIsUUFBUSxDQUFhO1FBQzVDLGlCQUFZLEdBQVosWUFBWSxDQUFnQjtRQUNOLGlCQUFZLEdBQVosWUFBWSxDQUFhO1FBR25FLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDO0lBQy9FLENBQUM7SUFFRCxzREFBc0Q7SUFDdEQsSUFBSSxnQkFBZ0I7UUFDbEIsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsSUFBSSxPQUFPLEVBQUUsQ0FBQztZQUN6QyxPQUFPLElBQUksQ0FBQyxZQUFZO2lCQUNyQixNQUFN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UUFBUSxDQUFDLE9BQU8sRUFDckIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQ3RCLENBQUM7UUFDSixNQUFNLGFBQWEsR0FBRyxhQUFhLEdBQUcsWUFBWSxHQUFHLENBQUMsQ0FBQztRQUN2RCxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FDaEQsSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVLENBQUMsYUFBYSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FDbEQsQ0FBQztRQUNGLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUNoRCxJQUFJLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUNsRCxDQUFDO1FBRUYsT0FBTyxDQUFDLFlBQVksRUFBRSxZQUFZLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRU8sR0FBRyxHQUFHLG1CQUFtQixnQkFBZ0IsRUFBRSxFQUFFLENBQUM7SUFFdEQsb0JBQW9CLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxlQUFlLENBQUM7dUdBcEt2QyxjQUFjLGtCQUVmLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUMsd0RBRWQsWUFBWTsyRkFKdkIsY0FBYyx5R0NqQzNCLG1sRUFvRkE7OzJGRG5EYSxjQUFjO2tCQVIxQixTQUFTO2lDQUNJLElBQUksWUFDTixpQkFBaUIsaUJBRVosaUJBQWlCLENBQUMsSUFBSSxtQkFDcEIsdUJBQXVCLENBQUMsTUFBTSxZQUNyQyxnQkFBZ0I7OzBCQUl2QixNQUFNOzJCQUFDLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUM7OzBCQUNqQyxRQUFROzswQkFDUixRQUFROzswQkFBSSxNQUFNOzJCQUFDLFlBQVkiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBDb21wb25lbnQsXG4gIGZvcndhcmRSZWYsXG4gIEluamVjdCxcbiAgT3B0aW9uYWwsXG4gIFZpZXdFbmNhcHN1bGF0aW9uLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRGF0ZUFkYXB0ZXIsIERBVEVfRk9STUFUUywgRGF0ZUZvcm1hdHMgfSBmcm9tICcuLi9hZGFwdGVyJztcbmltcG9ydCB7IGdldEFjdGl2ZU9mZnNldCwgaXNTYW1lTXVsdGlZZWFyVmlldywgeWVhcnNQZXJQYWdlIH0gZnJvbSAnLi9tdWx0aS15ZWFyLXZpZXcnO1xuaW1wb3J0IHsgQ2FsZW5kYXIgfSBmcm9tICcuL2NhbGVuZGFyJztcblxubGV0IGNhbGVuZGFySGVhZGVySWQgPSAxO1xuXG4vKiogRGVmYXVsdCBoZWFkZXIgZm9yIE1hdENhbGVuZGFyICovXG5AQ29tcG9uZW50KHtcbiAgc3RhbmRhbG9uZTogdHJ1ZSxcbiAgc2VsZWN0b3I6ICdjYWxlbmRhci1oZWFkZXInLFxuICB0ZW1wbGF0ZVVybDogJ2NhbGVuZGFyLWhlYWRlci5odG1sJyxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIGV4cG9ydEFzOiAnY2FsZW5kYXJIZWFkZXInLFxufSlcbmV4cG9ydCBjbGFzcyBDYWxlbmRhckhlYWRlcjxEPiB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBDYWxlbmRhcikpIHB1YmxpYyBjYWxlbmRhcjogQ2FsZW5kYXI8RD4sXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfZGF0ZUFkYXB0ZXI6IERhdGVBZGFwdGVyPEQ+LFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoREFURV9GT1JNQVRTKSBwcml2YXRlIF9kYXRlRm9ybWF0czogRGF0ZUZvcm1hdHMsXG4gICAgY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmXG4gICkge1xuICAgIHRoaXMuY2FsZW5kYXIuc3RhdGVDaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiBjaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKSk7XG4gIH1cblxuICAvKiogVGhlIGRpc3BsYXkgdGV4dCBmb3IgdGhlIGN1cnJlbnQgY2FsZW5kYXIgdmlldy4gKi9cbiAgZ2V0IHBlcmlvZEJ1dHRvblRleHQoKTogc3RyaW5nIHtcbiAgICBpZiAodGhpcy5jYWxlbmRhci5jdXJyZW50VmlldyA9PSAnbW9udGgnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGF0ZUFkYXB0ZXJcbiAgICAgICAgLmZvcm1hdCh0aGlzLmNhbGVuZGFyLmFjdGl2ZURhdGUsIHRoaXMuX2RhdGVGb3JtYXRzLmRpc3BsYXkubW9udGhZZWFyTGFiZWwpXG4gICAgICAgIC50b0xvY2FsZVVwcGVyQ2FzZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jYWxlbmRhci5jdXJyZW50VmlldyA9PSAneWVhcicpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kYXRlQWRhcHRlci5nZXRZZWFyTmFtZSh0aGlzLmNhbGVuZGFyLmFjdGl2ZURhdGUpO1xuICAgIH1cblxuICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IHRoaXMuX2Zvcm1hdE1pbkFuZE1heFllYXJMYWJlbHMoKTtcbiAgICByZXR1cm4gYCR7c3RhcnR9IFxcdTIwMTMgJHtlbmR9YDtcbiAgfVxuXG4gIC8qKiBUaGUgYXJpYSBkZXNjcmlwdGlvbiBmb3IgdGhlIGN1cnJlbnQgY2FsZW5kYXIgdmlldy4gKi9cbiAgZ2V0IHBlcmlvZEJ1dHRvbkRlc2NyaXB0aW9uKCk6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMuY2FsZW5kYXIuY3VycmVudFZpZXcgPT0gJ21vbnRoJykge1xuICAgICAgcmV0dXJuIHRoaXMuX2RhdGVBZGFwdGVyXG4gICAgICAgIC5mb3JtYXQodGhpcy5jYWxlbmRhci5hY3RpdmVEYXRlLCB0aGlzLl9kYXRlRm9ybWF0cy5kaXNwbGF5Lm1vbnRoWWVhckxhYmVsKVxuICAgICAgICAudG9Mb2NhbGVVcHBlckNhc2UoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2FsZW5kYXIuY3VycmVudFZpZXcgPT0gJ3llYXInKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhck5hbWUodGhpcy5jYWxlbmRhci5hY3RpdmVEYXRlKTtcbiAgICB9XG5cbiAgICAvLyBGb3JtYXQgYSBsYWJlbCBmb3IgdGhlIHdpbmRvdyBvZiB5ZWFycyBkaXNwbGF5ZWQgaW4gdGhlIG11bHRpLXllYXIgY2FsZW5kYXIgdmlldy4gVXNlXG4gICAgLy8gYGZvcm1hdFllYXJSYW5nZUxhYmVsYCBiZWNhdXNlIGl0IGlzIFRUUyBmcmllbmRseS5cbiAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSB0aGlzLl9mb3JtYXRNaW5BbmRNYXhZZWFyTGFiZWxzKCk7XG4gICAgcmV0dXJuIGAke3N0YXJ0fSBcXHUyMDEzICR7ZW5kfWA7XG4gIH1cblxuICAvKiogVGhlIGBhcmlhLWxhYmVsYCBmb3IgY2hhbmdpbmcgdGhlIGNhbGVuZGFyIHZpZXcuICovXG4gIGdldCBwZXJpb2RCdXR0b25MYWJlbCgpOiBzdHJpbmcge1xuICAgIC8vIFRPRE86IHRyYW5zbGF0ZVxuICAgIHJldHVybiB0aGlzLmNhbGVuZGFyLmN1cnJlbnRWaWV3ID09ICdtb250aCcgPyAnQ2hvb3NlIG1vbnRoIGFuZCB5ZWFyJyA6ICdDaG9vc2UgZGF0ZSc7XG4gIH1cblxuICAvKiogVGhlIGxhYmVsIGZvciB0aGUgcHJldmlvdXMgYnV0dG9uLiAqL1xuICBnZXQgcHJldkJ1dHRvbkxhYmVsKCk6IHN0cmluZyB7XG4gICAgLy8gVE9ETzogdHJhbnNsYXRlXG4gICAgcmV0dXJuIHtcbiAgICAgIG1vbnRoOiAnUHJldmlvdXMgbW9udGgnLFxuICAgICAgeWVhcjogJ1ByZXZpb3VzIHllYXInLFxuICAgICAgJ211bHRpLXllYXInOiAnUHJldmlvdXMgMjQgeWVhcnMnLFxuICAgIH1bdGhpcy5jYWxlbmRhci5jdXJyZW50Vmlld107XG4gIH1cblxuICAvKiogVGhlIGxhYmVsIGZvciB0aGUgbmV4dCBidXR0b24uICovXG4gIGdldCBuZXh0QnV0dG9uTGFiZWwoKTogc3RyaW5nIHtcbiAgICAvLyBUT0RPOiB0cmFuc2xhdGVcbiAgICByZXR1cm4ge1xuICAgICAgbW9udGg6ICdOZXh0IG1vbnRoJyxcbiAgICAgIHllYXI6ICdOZXh0IHllYXInLFxuICAgICAgJ211bHRpLXllYXInOiAnTmV4dCAyNCB5ZWFycycsXG4gICAgfVt0aGlzLmNhbGVuZGFyLmN1cnJlbnRWaWV3XTtcbiAgfVxuXG4gIC8qKiBIYW5kbGVzIHVzZXIgY2xpY2tzIG9uIHRoZSBwZXJpb2QgbGFiZWwuICovXG4gIGN1cnJlbnRQZXJpb2RDbGlja2VkKCk6IHZvaWQge1xuICAgIHRoaXMuY2FsZW5kYXIuY3VycmVudFZpZXcgPSB0aGlzLmNhbGVuZGFyLmN1cnJlbnRWaWV3ID09ICdtb250aCcgPyAnbXVsdGkteWVhcicgOiAnbW9udGgnO1xuICB9XG5cbiAgLyoqIEhhbmRsZXMgdXNlciBjbGlja3Mgb24gdGhlIHByZXZpb3VzIGJ1dHRvbi4gKi9cbiAgcHJldmlvdXNDbGlja2VkKCk6IHZvaWQge1xuICAgIHRoaXMuY2FsZW5kYXIuYWN0aXZlRGF0ZSA9XG4gICAgICB0aGlzLmNhbGVuZGFyLmN1cnJlbnRWaWV3ID09ICdtb250aCdcbiAgICAgICAgPyB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhck1vbnRocyh0aGlzLmNhbGVuZGFyLmFjdGl2ZURhdGUsIC0xKVxuICAgICAgICA6IHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFyWWVhcnMoXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyLmFjdGl2ZURhdGUsXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyLmN1cnJlbnRWaWV3ID09ICd5ZWFyJyA/IC0xIDogLXllYXJzUGVyUGFnZVxuICAgICAgICAgICk7XG4gIH1cblxuICAvKiogSGFuZGxlcyB1c2VyIGNsaWNrcyBvbiB0aGUgbmV4dCBidXR0b24uICovXG4gIG5leHRDbGlja2VkKCk6IHZvaWQge1xuICAgIHRoaXMuY2FsZW5kYXIuYWN0aXZlRGF0ZSA9XG4gICAgICB0aGlzLmNhbGVuZGFyLmN1cnJlbnRWaWV3ID09ICdtb250aCdcbiAgICAgICAgPyB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhck1vbnRocyh0aGlzLmNhbGVuZGFyLmFjdGl2ZURhdGUsIDEpXG4gICAgICAgIDogdGhpcy5fZGF0ZUFkYXB0ZXIuYWRkQ2FsZW5kYXJZZWFycyhcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXIuYWN0aXZlRGF0ZSxcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXIuY3VycmVudFZpZXcgPT0gJ3llYXInID8gMSA6IHllYXJzUGVyUGFnZVxuICAgICAgICAgICk7XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgcHJldmlvdXMgcGVyaW9kIGJ1dHRvbiBpcyBlbmFibGVkLiAqL1xuICBwcmV2aW91c0VuYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLmNhbGVuZGFyLm1pbkRhdGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgIXRoaXMuY2FsZW5kYXIubWluRGF0ZSB8fCAhdGhpcy5faXNTYW1lVmlldyh0aGlzLmNhbGVuZGFyLmFjdGl2ZURhdGUsIHRoaXMuY2FsZW5kYXIubWluRGF0ZSlcbiAgICApO1xuICB9XG5cbiAgLyoqIFdoZXRoZXIgdGhlIG5leHQgcGVyaW9kIGJ1dHRvbiBpcyBlbmFibGVkLiAqL1xuICBuZXh0RW5hYmxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgIXRoaXMuY2FsZW5kYXIubWF4RGF0ZSB8fCAhdGhpcy5faXNTYW1lVmlldyh0aGlzLmNhbGVuZGFyLmFjdGl2ZURhdGUsIHRoaXMuY2FsZW5kYXIubWF4RGF0ZSlcbiAgICApO1xuICB9XG5cbiAgLyoqIFdoZXRoZXIgdGhlIHR3byBkYXRlcyByZXByZXNlbnQgdGhlIHNhbWUgdmlldyBpbiB0aGUgY3VycmVudCB2aWV3IG1vZGUgKG1vbnRoIG9yIHllYXIpLiAqL1xuICBwcml2YXRlIF9pc1NhbWVWaWV3KGRhdGUxOiBELCBkYXRlMjogRCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLmNhbGVuZGFyLmN1cnJlbnRWaWV3ID09ICdtb250aCcpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXIoZGF0ZTEpID09IHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXIoZGF0ZTIpICYmXG4gICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyLmdldE1vbnRoKGRhdGUxKSA9PSB0aGlzLl9kYXRlQWRhcHRlci5nZXRNb250aChkYXRlMilcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNhbGVuZGFyLmN1cnJlbnRWaWV3ID09ICd5ZWFyJykge1xuICAgICAgcmV0dXJuIHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXIoZGF0ZTEpID09IHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXIoZGF0ZTIpO1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2Ugd2UgYXJlIGluICdtdWx0aS15ZWFyJyB2aWV3LlxuICAgIHJldHVybiBpc1NhbWVNdWx0aVllYXJWaWV3KFxuICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIsXG4gICAgICBkYXRlMSxcbiAgICAgIGRhdGUyLFxuICAgICAgdGhpcy5jYWxlbmRhci5taW5EYXRlLFxuICAgICAgdGhpcy5jYWxlbmRhci5tYXhEYXRlXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JtYXQgdHdvIGluZGl2aWR1YWwgbGFiZWxzIGZvciB0aGUgbWluaW11bSB5ZWFyIGFuZCBtYXhpbXVtIHllYXIgYXZhaWxhYmxlIGluIHRoZSBtdWx0aS15ZWFyXG4gICAqIGNhbGVuZGFyIHZpZXcuIFJldHVybnMgYW4gYXJyYXkgb2YgdHdvIHN0cmluZ3Mgd2hlcmUgdGhlIGZpcnN0IHN0cmluZyBpcyB0aGUgZm9ybWF0dGVkIGxhYmVsXG4gICAqIGZvciB0aGUgbWluaW11bSB5ZWFyLCBhbmQgdGhlIHNlY29uZCBzdHJpbmcgaXMgdGhlIGZvcm1hdHRlZCBsYWJlbCBmb3IgdGhlIG1heGltdW0geWVhci5cbiAgICovXG4gIHByaXZhdGUgX2Zvcm1hdE1pbkFuZE1heFllYXJMYWJlbHMoKTogW21pblllYXJMYWJlbDogc3RyaW5nLCBtYXhZZWFyTGFiZWw6IHN0cmluZ10ge1xuICAgIC8vIFRoZSBvZmZzZXQgZnJvbSB0aGUgYWN0aXZlIHllYXIgdG8gdGhlIFwic2xvdFwiIGZvciB0aGUgc3RhcnRpbmcgeWVhciBpcyB0aGVcbiAgICAvLyAqYWN0dWFsKiBmaXJzdCByZW5kZXJlZCB5ZWFyIGluIHRoZSBtdWx0aS15ZWFyIHZpZXcsIGFuZCB0aGUgbGFzdCB5ZWFyIGlzXG4gICAgLy8ganVzdCB5ZWFyc1BlclBhZ2UgLSAxIGF3YXkuXG4gICAgY29uc3QgYWN0aXZlWWVhciA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXIodGhpcy5jYWxlbmRhci5hY3RpdmVEYXRlKTtcbiAgICBjb25zdCBtaW5ZZWFyT2ZQYWdlID1cbiAgICAgIGFjdGl2ZVllYXIgLVxuICAgICAgZ2V0QWN0aXZlT2Zmc2V0KFxuICAgICAgICB0aGlzLl9kYXRlQWRhcHRlcixcbiAgICAgICAgdGhpcy5jYWxlbmRhci5hY3RpdmVEYXRlLFxuICAgICAgICB0aGlzLmNhbGVuZGFyLm1pbkRhdGUsXG4gICAgICAgIHRoaXMuY2FsZW5kYXIubWF4RGF0ZVxuICAgICAgKTtcbiAgICBjb25zdCBtYXhZZWFyT2ZQYWdlID0gbWluWWVhck9mUGFnZSArIHllYXJzUGVyUGFnZSAtIDE7XG4gICAgY29uc3QgbWluWWVhckxhYmVsID0gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhck5hbWUoXG4gICAgICB0aGlzLl9kYXRlQWRhcHRlci5jcmVhdGVEYXRlKG1pblllYXJPZlBhZ2UsIDAsIDEpXG4gICAgKTtcbiAgICBjb25zdCBtYXhZZWFyTGFiZWwgPSB0aGlzLl9kYXRlQWRhcHRlci5nZXRZZWFyTmFtZShcbiAgICAgIHRoaXMuX2RhdGVBZGFwdGVyLmNyZWF0ZURhdGUobWF4WWVhck9mUGFnZSwgMCwgMSlcbiAgICApO1xuXG4gICAgcmV0dXJuIFttaW5ZZWFyTGFiZWwsIG1heFllYXJMYWJlbF07XG4gIH1cblxuICBwcml2YXRlIF9pZCA9IGBjYWxlbmRhci1oZWFkZXItJHtjYWxlbmRhckhlYWRlcklkKyt9YDtcblxuICBfcGVyaW9kQnV0dG9uTGFiZWxJZCA9IGAke3RoaXMuX2lkfS1wZXJpb2QtbGFiZWxgO1xufVxuIiwiPGRpdiBjbGFzcz1cInB4LTMgcHQtMi41IHBiLTAgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuXCI+XG4gIDwhLS0gW0ZpcmVmb3ggSXNzdWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE4ODA1MzNdXG4gICAgUmVsb2NhdGVkIGxhYmVsIG5leHQgdG8gcmVsYXRlZCBidXR0b24gYW5kIG1hZGUgdmlzdWFsbHkgaGlkZGVuIHZpYSBjZGstdmlzdWFsbHktaGlkZGVuXG4gICAgdG8gZW5hYmxlIGxhYmVsIHRvIGFwcGVhciBpbiBhMTF5IHRyZWUgZm9yIFNSIHdoZW4gdXNpbmcgRmlyZWZveCAtLT5cbiAgPGxhYmVsXG4gICAgY2xhc3M9XCJoaWRkZW4gY2RrLXZpc3VhbGx5LWhpZGRlblwiXG4gICAgZm9yPVwiXCJcbiAgICBbaWRdPVwiX3BlcmlvZEJ1dHRvbkxhYmVsSWRcIlxuICA+XG4gICAge3sgcGVyaW9kQnV0dG9uRGVzY3JpcHRpb24gfX1cbiAgPC9sYWJlbD5cblxuICA8YnV0dG9uXG4gICAgY2xhc3M9XCJidG4gYnRuLWdob3N0XCJcbiAgICBhcmlhLWxpdmU9XCJwb2xpdGVcIlxuICAgIFthdHRyLmFyaWEtbGFiZWxdPVwicGVyaW9kQnV0dG9uTGFiZWxcIlxuICAgIFthdHRyLmFyaWEtZGVzY3JpYmVkYnldPVwiX3BlcmlvZEJ1dHRvbkxhYmVsSWRcIlxuICAgIChjbGljayk9XCJjdXJyZW50UGVyaW9kQ2xpY2tlZCgpXCJcbiAgPlxuICAgIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPnt7IHBlcmlvZEJ1dHRvblRleHQgfX08L3NwYW4+XG5cbiAgICA8c3ZnXG4gICAgICBjbGFzcz1cInctMyBoLTNcIlxuICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgdmlld0JveD1cIjAgMCAyNCAyNFwiXG4gICAgICBzdHJva2Utd2lkdGg9XCIzXCJcbiAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgPlxuICAgICAgPHBhdGhcbiAgICAgICAgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiXG4gICAgICAgIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCJcbiAgICAgICAgZD1cIm0xOS41IDguMjUtNy41IDcuNS03LjUtNy41XCJcbiAgICAgIC8+XG4gICAgPC9zdmc+XG4gIDwvYnV0dG9uPlxuXG4gIDxkaXYgY2xhc3M9XCJmbGV4LWF1dG9cIj48L2Rpdj5cblxuICA8bmctY29udGVudCAvPlxuXG4gIDxidXR0b25cbiAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICBjbGFzcz1cImJ0biBidG4tZ2hvc3QgYnRuLWNpcmNsZSBidG4tc21cIlxuICAgIFtkaXNhYmxlZF09XCIhcHJldmlvdXNFbmFibGVkKClcIlxuICAgIFthdHRyLmFyaWEtbGFiZWxdPVwicHJldkJ1dHRvbkxhYmVsXCJcbiAgICAoY2xpY2spPVwicHJldmlvdXNDbGlja2VkKClcIlxuICA+XG4gICAgPHN2Z1xuICAgICAgY2xhc3M9XCJ3LTYgaC02XCJcbiAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgIHZpZXdCb3g9XCIwIDAgMjQgMjRcIlxuICAgICAgc3Ryb2tlLXdpZHRoPVwiMlwiXG4gICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgID5cbiAgICAgIDxwYXRoXG4gICAgICAgIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIlxuICAgICAgICBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiXG4gICAgICAgIGQ9XCJNMTUuNzUgMTkuNSA4LjI1IDEybDcuNS03LjVcIlxuICAgICAgLz5cbiAgICA8L3N2Zz5cbiAgPC9idXR0b24+XG5cbiAgPGJ1dHRvblxuICAgIHR5cGU9XCJidXR0b25cIlxuICAgIGNsYXNzPVwiYnRuIGJ0bi1naG9zdCBidG4tY2lyY2xlIGJ0bi1zbVwiXG4gICAgW2Rpc2FibGVkXT1cIiFuZXh0RW5hYmxlZCgpXCJcbiAgICBbYXR0ci5hcmlhLWxhYmVsXT1cIm5leHRCdXR0b25MYWJlbFwiXG4gICAgKGNsaWNrKT1cIm5leHRDbGlja2VkKClcIlxuICA+XG4gICAgPHN2Z1xuICAgICAgY2xhc3M9XCJ3LTYgaC02XCJcbiAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgIHZpZXdCb3g9XCIwIDAgMjQgMjRcIlxuICAgICAgc3Ryb2tlLXdpZHRoPVwiMlwiXG4gICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgID5cbiAgICAgIDxwYXRoXG4gICAgICAgIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIlxuICAgICAgICBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiXG4gICAgICAgIGQ9XCJtOC4yNSA0LjUgNy41IDcuNS03LjUgNy41XCJcbiAgICAgIC8+XG4gICAgPC9zdmc+XG4gIDwvYnV0dG9uPlxuPC9kaXY+XG4iXX0=