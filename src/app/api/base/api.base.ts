import { HttpClient } from '@angular/common/http';
import { inject } from '@angular/core';

import { environment } from '@environment';
import { Observable, of, tap } from 'rxjs';

import { PagingDataModel, PagingResponseModel, ResponseModel } from '../models';
import { BaseAPIOperator } from './operators';

/**
 * Base API Service
 */
export class BaseApiService<T = any> {
  protected _baseUrl = environment.apiUrl;
  protected _http = inject(HttpClient);

  protected _cacheMap = new Map<string, any>();

  // -----------------------------------------------------------------------------------------------------
  // @ Public methods
  // -----------------------------------------------------------------------------------------------------

  clearCache() {
    this._cacheMap.clear();
  }

  // -----------------------------------------------------------------------------------------------------
  // @ Protected methods
  // -----------------------------------------------------------------------------------------------------

  /**
   * @description List all items
   * @returns Observable<T[]> array of items
   */
  protected _list(): Observable<T[]> {
    if (this._cacheMap.has(this._baseUrl)) {
      return of(this._cacheMap.get(this._baseUrl));
    }

    return this._http.get<ResponseModel<T[]>>(this._baseUrl).pipe(
      BaseAPIOperator.responseHandler(),
      tap((data) => {
        this._cacheMap.set(this._baseUrl, data);
      })
    );
  }

  /**
   * @description List all items with pagination
   * @param page page index 1-based
   * @param size number of items per page
   * @returns Observable<PagingDataModel<T>> array of items with pagination
   */
  protected _paginate(
    page: number,
    size: number,
    pattern?: string
  ): Observable<PagingDataModel<T>> {
    const params = new URLSearchParams();
    params.append('page', page.toString());
    params.append('pageSize', size.toString());

    if (pattern) {
      params.append('keyword', pattern);
    }

    return this._http
      .get<PagingResponseModel<T>>(`${this._baseUrl}?${params.toString()}`)
      .pipe(BaseAPIOperator.responseHandler(), BaseAPIOperator.pagingHandler());
  }

  /**
   * @description Read an item by id
   * @param id guid of item
   * @returns Observable<T> full item model
   */
  protected _read(id: string): Observable<T> {
    return this._http
      .get<ResponseModel<T>>(`${this._baseUrl}/${id}`)
      .pipe(BaseAPIOperator.responseHandler());
  }

  /**
   * @description Create an item
   * @param data item model
   * @returns Observable<T> item model with guid generated by server
   */
  protected _create(data: Partial<T>): Observable<T> {
    return this._http.post<ResponseModel<T>>(this._baseUrl, data).pipe(
      BaseAPIOperator.responseHandler(),
      tap(() => this._cacheMap.clear())
    );
  }

  /**
   * @description Update full item
   * @param id guid of item
   * @param data full item model
   * @returns Observable<T> item model that updated
   */
  protected _update(id: string, data: Partial<T>): Observable<T> {
    return this._http.put<ResponseModel<T>>(`${this._baseUrl}/${id}`, data).pipe(
      BaseAPIOperator.responseHandler(),
      tap(() => this._cacheMap.clear())
    );
  }

  /**
   * @description Update partial item
   * @param id guid of item
   * @param data partial item model
   * @returns Observable<T> item model that updated
   */
  protected _patch(id: string, data: Partial<T>): Observable<T> {
    return this._http.patch<ResponseModel<T>>(`${this._baseUrl}/${id}`, data).pipe(
      BaseAPIOperator.responseHandler(),
      tap(() => this._cacheMap.clear())
    );
  }

  /**
   * @description Delete an item
   * @param id guid of item
   * @returns Observable<T> boolean value
   */
  protected _delete(id: string): Observable<boolean> {
    return this._http.delete<ResponseModel<boolean>>(`${this._baseUrl}/${id}`).pipe(
      BaseAPIOperator.responseHandler(),
      tap(() => this._cacheMap.clear())
    );
  }
}
